// leetcode题号: 200
// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
// 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
// 此外，你可以假设该网格的四条边均被水包围。

// 示例 1：
// 输入：grid = [
//   ["1","1","1","1","0"],
//   ["1","1","0","1","0"],
//   ["1","1","0","0","0"],
//   ["0","0","0","0","0"]
// ]
// 输出：1

// 示例 2：
// 输入：grid = [
//   ["1","1","0","0","0"],
//   ["1","1","0","0","0"],
//   ["0","0","1","0","0"],
//   ["0","0","0","1","1"]
// ]
// 输出：3

// dfs 通用框架
// dfs 深度优先递归遍历
function dfs(grid, x, y) {
  let m = grid.length;
  let n = grid[0].length;
  if (x < 0 || x >= m || y < 0 || y >= n) {
    return;
  }

  // 如果是标记为2的遇到过的,或者是水,则结束
  if (grid[x][y] !== "1") {
    return;
  }

  // 遇到过的位置标记为2
  grid[x][y] = "2";

  dfs(grid, x + 1, y);
  dfs(grid, x, y + 1);
  dfs(grid, x - 1, y);
  dfs(grid, x, y - 1);
}

function numIslands(grid) {
  if (grid.length === 0) return 0;

  let result = 0;

  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      // 如果是水0,或者是遍历过的2,则不进入判断
      if (grid[i][j] === "1") {
        // 遇到陆地的起点,计数+1
        result++;
        // 递归遍历,寻找陆地的范围
        dfs(grid, i, j);
      }
    }
  }
  return result;
}

console.log(
  numIslands([
    ["1", "1", "1", "1", "0"],
    ["1", "1", "0", "1", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "0", "0", "0"],
  ])
); // 1

console.log(
  numIslands([
    ["1", "1", "0", "0", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "1", "0", "0"],
    ["0", "0", "0", "1", "1"],
  ])
); // 3
