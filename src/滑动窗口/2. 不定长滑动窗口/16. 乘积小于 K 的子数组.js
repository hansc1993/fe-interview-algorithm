// leetcode题号：713
// 给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。

// 示例 1：
// 输入：nums = [10,5,2,6], k = 100
// 输出：8
// 解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2]、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
// 需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。

// 示例 2：
// 输入：nums = [1,2,3], k = 0
// 输出：0

// 题解：
// 如何计算 增量 子数组数量是个难点，首先我们看看窗口内的子数组怎么“数”的问题，比如数组[1,2,3,4]，当前窗口[1,2,3]。

// 我们全量数一次窗口内的子数组: [1], [1,2], [1,2,3], [2], [2,3], [3], 一共6个，当right右移后，窗口变成[1,2,3,4]，这时如果我们再进行“全量数”，上一个窗口[1,2,3]就被重复计算了。

// 为了消除这种重复，我们需要使用“增量数”，从右向左看，right右移后，窗口新增一个元素，会新增哪些子数组？ 例如[1,2,3] -> [1,2,3,4] 窗口内新增一个元素4时，新增的子数组肯定要包含4，以4为右端点，新增的子数组是[4],[3,4],[2,3,4],[1,2,3,4]， 一共4个，这个增量就是窗口大小right-left+1。

// 如果从l到r这一段的乘积是小于k的
// 那么[l, r], [l+1, r], [l+2, r]...[r, r] 都是小于k的
// 所以子数组的数量为r - l + 1
function numSubarrayProductLessThanK(nums, k) {
    let ans = 0
    let left = 0
    let sum = 1

    if(k <= 1) return 0

    for(let right=0;right<nums.length;right++) {
        sum *= nums[right]      
        while(sum >= k) {
            sum /= nums[left]
            left++
        }
        ans += right - left + 1
    }
    return ans
}

console.log(numSubarrayProductLessThanK([10,5,2,6], 100)) // 8
console.log(numSubarrayProductLessThanK([1,2,3], 0)) // 0